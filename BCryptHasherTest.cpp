/// @file   BCryptHasherTest.cpp
/// @date   2019.07.23
/// @author ttsuki

/// MIT License
/// 
/// Copyright(c) 2019 ttsuki
/// 
/// Permission is hereby granted, free of charge, to any person obtaining a copy
/// of this software and associated documentation files(the "Software"), to deal
/// in the Software without restriction, including without limitation the rights
/// to use, copy, modify, merge, publish, distribute, sublicense, and /or sell
/// copies of the Software, and to permit persons to whom the Software is
/// furnished to do so, subject to the following conditions :
/// 
/// The above copyright notice and this permission notice shall be included in all
/// copies or substantial portions of the Software.
/// 
/// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
/// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
/// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE
/// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
/// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
/// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
/// SOFTWARE.

#include <iostream>
#include <iomanip>
#include <cstdint>
#include <string>
#include <vector>

#include "BCryptHasher.h"

static void Test();

int main()
{
	{
		// Sign with HMAC-SHA-256.
		auto signer = BCryptHasher::CreateHmacSha256Signer("Jefe", 4); // HMACKey, and KeyLength
		signer->Update("what do ya want ", 16);
		signer->Update("for nothing?", 12);
		auto signature = signer->Finish();

		// Print the signature.
		for (auto c : signature)
		{
			std::cout << std::hex << std::setfill('0') << std::setw(2) << static_cast<int>(c);
		}
		std::cout << std::endl;
	}

	Test();
	return 0;
}


static void TestHasher(
	const std::string& test,
	std::unique_ptr<BCryptHasher::IHasher> hasher,
	const std::string& data,
	const std::vector<uint8_t>& expected)
{
	hasher->Update(data.data(), data.size());
	auto calculated = hasher->Finish();

	std::cout << "- " << test << std::endl;

	std::cout << "   expected: ";
	for (auto c : expected) { std::cout << std::hex << std::setfill('0') << std::setw(2) << static_cast<int>(c); }
	std::cout << std::endl;

	std::cout << " calculated: ";
	for (auto c : calculated) { std::cout << std::hex << std::setfill('0') << std::setw(2) << static_cast<int>(c); }
	std::cout << " " << (calculated == expected ? "OK." : "BAD.") << std::endl;
}

static std::string AsString(const std::vector<uint8_t>& v)
{
	return std::string(v.begin(), v.end());
}

static void TestHmacSigner(
	const std::string& test,
	BCryptHasher::HashAlgorithm algo,
	const std::string& key,
	const std::string& data,
	const std::vector<uint8_t>& expected)
{
	TestHasher(test, CreateBCryptHmacSigner(algo, key.data(), key.size()), data, expected);
}

static void Test()
{
	{
		auto key = "Jefe";
		auto data =
			"what do ya want "
			"for nothing?";

		TestHmacSigner(
			"HMAC-MD5 (rfc2202 Test Case 2)",
			BCryptHasher::HashAlgorithm::Md5, key, data,
			{
				0x75, 0x0c, 0x78, 0x3e, 0x6a, 0xb0, 0xb5, 0x03, 0xea, 0xa8, 0x6e, 0x31, 0x0a, 0x5d, 0xb7, 0x38
			});

		TestHmacSigner(
			"HMAC-SHA-1 (rfc2202 Test Case 2)",
			BCryptHasher::HashAlgorithm::Sha1, key, data,
			{
				0xef, 0xfc, 0xdf, 0x6a, 0xe5, 0xeb, 0x2f, 0xa2, 0xd2, 0x74, 0x16, 0xd5, 0xf1, 0x84, 0xdf, 0x9c,
				0x25, 0x9a, 0x7c, 0x79
			}
		);

		TestHmacSigner(
			"HMAC-SHA-256 (rfc4231 Test Case 2)",
			BCryptHasher::HashAlgorithm::Sha256, key, data,
			{
				0x5b, 0xdc, 0xc1, 0x46, 0xbf, 0x60, 0x75, 0x4e, 0x6a, 0x04, 0x24, 0x26, 0x08, 0x95, 0x75, 0xc7,
				0x5a, 0x00, 0x3f, 0x08, 0x9d, 0x27, 0x39, 0x83, 0x9d, 0xec, 0x58, 0xb9, 0x64, 0xec, 0x38, 0x43,
			}
		);
	}

	{
		auto key = AsString({
			0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
			0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
			0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
			0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
			0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
			0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
			0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
			0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
			0xaa, 0xaa, 0xaa
		});

		auto data =
			"This is a test u"
			"sing a larger th"
			"an block-size ke"
			"y and a larger t"
			"han block-size d"
			"ata. The key nee"
			"ds to be hashed "
			"before being use"
			"d by the HMAC al"
			"gorithm.";

		TestHmacSigner(
			"HMAC-SHA-256 (rfc4231 Test Case 7)",
			BCryptHasher::HashAlgorithm::Sha256, key, data,
			{
				0x9b, 0x09, 0xff, 0xa7, 0x1b, 0x94, 0x2f, 0xcb, 0x27, 0x63, 0x5f, 0xbc, 0xd5, 0xb0, 0xe9, 0x44,
				0xbf, 0xdc, 0x63, 0x64, 0x4f, 0x07, 0x13, 0x93, 0x8a, 0x7f, 0x51, 0x53, 0x5c, 0x3a, 0x35, 0xe2,
			}
		);

		TestHmacSigner(
			"HMAC-SHA-512 (rfc4231 Test Case 7)",
			BCryptHasher::HashAlgorithm::Sha512, key, data,
			{
				0xe3, 0x7b, 0x6a, 0x77, 0x5d, 0xc8, 0x7d, 0xba, 0xa4, 0xdf, 0xa9, 0xf9, 0x6e, 0x5e, 0x3f, 0xfd,
				0xde, 0xbd, 0x71, 0xf8, 0x86, 0x72, 0x89, 0x86, 0x5d, 0xf5, 0xa3, 0x2d, 0x20, 0xcd, 0xc9, 0x44,
				0xb6, 0x02, 0x2c, 0xac, 0x3c, 0x49, 0x82, 0xb1, 0x0d, 0x5e, 0xeb, 0x55, 0xc3, 0xe4, 0xde, 0x15,
				0x13, 0x46, 0x76, 0xfb, 0x6d, 0xe0, 0x44, 0x60, 0x65, 0xc9, 0x74, 0x40, 0xfa, 0x8c, 0x6a, 0x58
			}
		);
	}
}
